import { useEffect, useRef, useState, useCallback } from "react";
import { useRouter, useSearchParams } from "next/navigation";

type GamePlayer = {
    id: string;
    name: string;
    points: number;
    isHost: boolean;
};

type GameRoom = {
    id: string;
    players: GamePlayer[];
    status: "waiting" | "playing";
    roundNumber: number;
    boardState: string[][] | null;
    turnIndex: number;
};

type GameMessage = {
    type: "room_updated" | "gameboard_update" | "turn_update" | "round_update" | "player_score_update" | "connected" | "error";
    content?: {
        board?: string[][];
        turnIndex?: number;
        roundNumber?: number;
        playerId?: string;
        points?: number;
        room?: GameRoom;
    };
};

export const useGameWebSocket = (initialRoomId?: string) => {
    const router = useRouter();
    const searchParams = useSearchParams();
    const ws = useRef<WebSocket | null>(null);
    const [isConnected, setIsConnected] = useState(false);
    const [currentRoom, setCurrentRoom] = useState<GameRoom | null>(null);
    const [playerId, setPlayerId] = useState<string | null>(null);
    const [messages, setMessages] = useState<GameMessage[]>([]);

    const reconnectAttempts = useRef(0);
    const maxReconnectAttempts = 5;
    const reconnectTimeout = useRef<NodeJS.Timeout | null>(null);

    // ðŸ”¹ Generates a randomized board (5x5 letters)
    const generateRandomBoard = () => {
        const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("");
        let shuffled = [...alphabet].sort(() => Math.random() - 0.5);
        return Array.from({ length: 5 }, (_, i) => shuffled.slice(i * 5, i * 5 + 5));
    };

    // ðŸ”¹ Handles room updates and persists state
    const handleRoomUpdate = useCallback((roomData: GameRoom) => {
        console.log("ðŸ”„ Updating Room:", roomData);
        setCurrentRoom(roomData);
    }, []);

    useEffect(() => {
        if (!currentRoom || !playerId) return;

        const isHost = currentRoom.players?.some(p => p.id === playerId && p.isHost);
        const currentRoomId = searchParams.get("roomId");

        // Update URL with the room ID if missing
        if (isHost && !currentRoomId) {
            console.log("ðŸŒ Updating URL with Room ID:", currentRoom.id);
            const params = new URLSearchParams(searchParams.toString());
            params.set("roomId", currentRoom.id);
            router.replace(`?${params.toString()}`, { scroll: false });
        }

        // Ensure board is generated by the host if missing
        if (isHost && (!currentRoom.boardState || currentRoom.boardState.length === 0)) {
            console.log("ðŸ›  Host generating new board...");
            const newBoard = generateRandomBoard();
            setCurrentRoom(prev => prev ? { ...prev, boardState: newBoard } : null); // âœ… Update local state
            sendGameMessage("gameboard_update", { board: newBoard });
        }
    }, [currentRoom, playerId, router, searchParams]);

    // ðŸ”¹ Handles WebSocket connection and reconnection logic
    const connect = useCallback(() => {
        if (typeof window === "undefined" || ws.current?.readyState === WebSocket.OPEN) return;

        const protocol = window.location.protocol === "https:" ? "wss:" : "ws:";
        const wsUrl = `${protocol}//localhost:3001`;

        ws.current = new WebSocket(wsUrl);

        ws.current.onopen = () => {
            console.log("ðŸŸ¢ WebSocket connected");
            setIsConnected(true);
            reconnectAttempts.current = 0;

            const roomId = initialRoomId || searchParams.get("roomId") || Math.random().toString(36).substring(2, 9);
            let storedPlayerId = localStorage.getItem("playerId");
            let isHost = localStorage.getItem("isHost") === "true";

            if (!storedPlayerId) {
                storedPlayerId = Math.random().toString(36).substring(2, 9);
                localStorage.setItem("playerId", storedPlayerId);
            }

            if (!searchParams.get("roomId")) {
                isHost = true;
                localStorage.setItem("isHost", "true");
            }

            console.log("ðŸ“¨ Sending join_room request:", { roomId, storedPlayerId, isHost });

            ws.current?.send(
                JSON.stringify({
                    type: "join_room",
                    roomId,
                    playerId: storedPlayerId,
                    isHost,
                })
            );

            setPlayerId(storedPlayerId);
        };

        ws.current.onmessage = (event) => {
            try {
                const data: GameMessage = JSON.parse(event.data);
                console.log("ðŸ“© [WebSocket Message Received]:", data);

                setMessages(prev => [...prev, data]); // âœ… Store messages in state

                if (data.type === "room_updated") {
                    if (!data.content?.room) {
                        console.error("âŒ Received 'room_updated' but room is undefined!", data);
                        return;
                    }
                    console.log("ðŸ”„ Updating Room:", data.content.room);
                    handleRoomUpdate(data.content.room);
                }

                switch (data.type) {
                    case "room_updated":
                        handleRoomUpdate(data.content as GameRoom);
                        break;

                    case "gameboard_update":
                        console.log("ðŸ“œ New Board State Received:", data.content?.board);
                        setCurrentRoom(prev => prev ? { ...prev, boardState: data.content?.board ?? prev.boardState } : null);
                        break;

                    case "turn_update":
                        setCurrentRoom(prev => prev ? { ...prev, turnIndex: data.content?.turnIndex ?? prev.turnIndex } : null);
                        break;

                    case "round_update":
                        setCurrentRoom(prev => prev ? { ...prev, roundNumber: data.content?.roundNumber ?? prev.roundNumber, turnIndex: 0 } : null);
                        break;

                    case "player_score_update":
                        setCurrentRoom(prev => {
                            if (!prev) return null;
                            return {
                                ...prev,
                                players: prev.players.map(player =>
                                    player.id === data.content?.playerId
                                        ? { ...player, points: data.content?.points ?? player.points }
                                        : player
                                ),
                            };
                        });
                        break;

                    case "connected":
                        console.log("âœ… WebSocket Connected");
                        break;

                    case "error":
                        console.error("âŒ Game error:", data.content);
                        break;

                    default:
                        console.warn("âš ï¸ Unknown message type:", data);
                        break;
                }
            } catch (error) {
                console.error("âŒ Error parsing game message:", error);
            }
        };

        ws.current.onerror = (error) => {
            console.error("âŒ WebSocket error:", error);
        };

        ws.current.onclose = (event) => {
            console.log("ðŸ”´ WebSocket closed:", event.code, event.reason);
            setIsConnected(false);
            setCurrentRoom(null);

            if (reconnectAttempts.current < maxReconnectAttempts) {
                reconnectAttempts.current += 1;
                reconnectTimeout.current = setTimeout(connect, 2000);
            }
        };
    }, [initialRoomId, searchParams, handleRoomUpdate]);

    useEffect(() => {
        connect();
        return () => {
            if (ws.current) {
                ws.current.close();
                ws.current = null;
            }
            if (reconnectTimeout.current) {
                clearTimeout(reconnectTimeout.current);
            }
        };
    }, []);

    const sendGameMessage = useCallback((type: string, content?: any) => {
        if (!ws.current || ws.current.readyState !== WebSocket.OPEN || !currentRoom || !playerId) {
            console.error("âŒ Cannot send message: WebSocket not ready or missing room/player info.");
            return;
        }

        try {
            ws.current.send(JSON.stringify({
                type,
                roomId: currentRoom.id,
                playerId,
                content,
                timestamp: new Date().toISOString(),
            }));
        } catch (error) {
            console.error("âŒ Error sending game message:", error);
        }
    }, [currentRoom, playerId]);

    return {
        isConnected,
        currentRoom,
        playerId,
        messages, // âœ… Ensure messages are included
        isHost: currentRoom?.players?.some(p => p.id === playerId && p.isHost) ?? false,
        sendGameMessage,
    };
};
